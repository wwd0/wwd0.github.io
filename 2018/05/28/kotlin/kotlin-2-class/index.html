<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>二、kotlin--&gt;类和接口 | 凡星的个人博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">二、kotlin--&gt;类和接口</h1><a id="logo" href="/.">凡星的个人博客</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">二、kotlin--&gt;类和接口</h1><div class="post-meta">May 28, 2018<span> | </span><span class="category"><a href="/categories/kotlin/">kotlin</a></span></div><div class="post-content"><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h3><p>java类使用extends继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyClass extends BaseClass &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而kotlin使用冒号:继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyClass : BaseClass() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>kotlin的class默认不允许被继承, 如果想要被继承，得要添加open关键字。</p>
<h3 id="2-覆写方法"><a href="#2-覆写方法" class="headerlink" title="2.覆写方法"></a>2.覆写方法</h3><p>kotlin中方法也是默认不可覆写的，如果子类要覆写父类的方法，得要在父类的方法前面加open关键字，然后在子类的方法前加override<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//父类</span><br><span class="line">open class Person&#123;</span><br><span class="line">	open fun getName()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子类</span><br><span class="line">class Girl : Person()&#123;</span><br><span class="line">	override fun getName()&#123;</span><br><span class="line">		super.getName()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h3><p>java和kotlin都使用interface关键字声明接口。但是二者实现接口方式不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//java使用implements实现接口</span><br><span class="line">class MyClass implements A,B&#123;&#125;</span><br><span class="line"></span><br><span class="line">//kotlin还是使用冒号:实现接口</span><br><span class="line">class MyKotlin : A,B&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>kotlin中既然继承和实现接口都是使用冒号: 那同时继承和实现接口怎么写呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Girl : Person, A,B&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口中的属性和方法默认都是open的，不需要另外添加。<br>java中的接口的方法不能有方法体,但kotlin可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface IPerson&#123;</span><br><span class="line">	fun getName() : String</span><br><span class="line">	fun getAge() : Int&#123;</span><br><span class="line">		return 18</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Man : IPerson &#123;</span><br><span class="line">	override fun getName() : String&#123;</span><br><span class="line">		return &quot;张飞&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-创建类的实例"><a href="#4-创建类的实例" class="headerlink" title="4.创建类的实例"></a>4.创建类的实例</h3><p>java使用new关键字创建实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = new User();</span><br></pre></td></tr></table></figure></p>
<p>kotlin没有new关键字。直接创建即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var user = User()</span><br></pre></td></tr></table></figure></p>
<h3 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5.构造函数"></a>5.构造函数</h3><p>在Kotlin中，主构造函数是类头的一部分：它跟在类名后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class User constructor(userName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class User(userName: String) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Kotlin的主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的代码块中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class User(userName: String) &#123;</span><br><span class="line">    init &#123;       </span><br><span class="line">    //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Kotlin的次构造函数前面必须加constructor关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class User(userName: String) &#123;</span><br><span class="line">    //主构造函数的实现部分</span><br><span class="line">    init &#123;</span><br><span class="line">        println(userName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //次构造函数，可通过this调主构造函数</span><br><span class="line">    constructor() : this(&quot;czh&quot;)</span><br><span class="line"></span><br><span class="line">    //次构造函数，可通过this调主构造函数</span><br><span class="line">    constructor(age: Int) : this(&quot;czh&quot;) &#123;</span><br><span class="line">        println(age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //次构造函数，通过this调主构造函数</span><br><span class="line">    constructor(sex: String, age: Int) : this(&quot;czh&quot;) &#123;</span><br><span class="line">        println(&quot;$sex$age&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例化User</span><br><span class="line">User()</span><br><span class="line">User(&quot;Czh&quot;)</span><br><span class="line">User(2)</span><br><span class="line">User(&quot;男&quot;,22)</span><br></pre></td></tr></table></figure></p>
<h3 id="6-可见性修饰符"><a href="#6-可见性修饰符" class="headerlink" title="6.可见性修饰符"></a>6.可见性修饰符</h3><p>java有public, protected, default, private 4个可见性修饰符。<br>kotlin有: internal, public, protected, private 4个修饰符<br>与Java可见性修饰符的可见性修饰符不同的是，多了一个internal，少了一个default。 internal 意味着该成员只在相同模块内可见。更具体地说， 一个模块是编译在一起的一套 Kotlin 文件</p>
<h3 id="7-嵌套类"><a href="#7-嵌套类" class="headerlink" title="7.嵌套类"></a>7.嵌套类</h3><p>嵌套类指的是在类中定义的类，如下所示： Java中的嵌套类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Dialog&#123;</span><br><span class="line">	String title;</span><br><span class="line"></span><br><span class="line">	static class Builder&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Dialog.Builder builder = new Dialog.Builder();</span><br></pre></td></tr></table></figure></p>
<p>kotlin使用inner关键字声明嵌套类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Dialog&#123;</span><br><span class="line">	var title = &quot;&quot;</span><br><span class="line"></span><br><span class="line">	inner class Builder&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var builder = Dialog().Builder()</span><br><span class="line">//var builder : Dialog.Builder = Dialog().Builder()</span><br></pre></td></tr></table></figure></p>
<h3 id="8-调用属性"><a href="#8-调用属性" class="headerlink" title="8. 调用属性"></a>8. 调用属性</h3><p>java中需要加上get,set方法才可以调用属性，而且开发工具有专门的菜单键来生成getter,setter方法<br>但kotlin中不需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">	var name : String = &quot;&quot;</span><br><span class="line">	var age = 18</span><br><span class="line">&#125;</span><br><span class="line">Student().name //相当于getName</span><br><span class="line">Student().age = 17 //相当于setAge</span><br></pre></td></tr></table></figure></p>
<p>当然,kotlin也支持在类中显示定义get,set方法，这里就不展开了。</p>
<h3 id="9-数据类"><a href="#9-数据类" class="headerlink" title="9.数据类"></a>9.数据类</h3><p>kotlin中存在数据类这一概念，相当于Java中的实体bean,model<br>kotlin中使用data关键字标识数据类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class Student(var name : String, var age : Int)</span><br></pre></td></tr></table></figure></p>
<p>创建数据类需要注意的是：</p>
<p>主构造方法至少要有一个参数，且参数必须标记为val或var<br>数据类不能用open、abstract、sealed(封闭类)、inner标识<br>声明一个类为数据类后，除了可以直接使用属性外，还能调用copy函数。<br>简单解释一下copy()函数。在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var user = User(&quot;张三&quot;, 22)</span><br><span class="line">var user1 = user.copy(age = 23)</span><br><span class="line">Toast.makeText(this, user1.toString(), Toast.LENGTH_SHORT).show()</span><br><span class="line">可以看到姓名还是张三，但年龄为23</span><br></pre></td></tr></table></figure></p>
<h3 id="10-函数的参数"><a href="#10-函数的参数" class="headerlink" title="10. 函数的参数"></a>10. 函数的参数</h3><p>kotlin的函数支持默认参数，若调用时不指定参数，就会使用默认参数，而java并不支持默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//给i指定默认值为1</span><br><span class="line">fun foo(str: String, i: Int = 1) &#123;</span><br><span class="line">    println(&quot;$str  $i&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//调用该函数，这个时候可以只传一个参数</span><br><span class="line">foo(&quot;abc&quot;)</span><br><span class="line">//运行代码，得到结果为： abc  1</span><br></pre></td></tr></table></figure></p>
<p>但是如果将默认值参数放到无默认值参数前，以上方式就会出错。还是上面代码,只是修改了foo方法参数位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//给i指定默认值为1</span><br><span class="line">fun foo(i: Int = 1, str: String) &#123;</span><br><span class="line">    println(&quot;$str  $i&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&quot;abc&quot;) //编译错误</span><br><span class="line">foo(str = &quot;hello&quot;)  //编译通过，要使用参数的命名来指定值</span><br><span class="line">//运行代码，得到结果为： hello  1</span><br></pre></td></tr></table></figure></p>
<p>上面这个情况也叫 命名参数</p>
<p>可变数量的参数： 函数的参数可以用 vararg 修饰符标记，表示允许将可变数量的参数传递给函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//用 vararg 修饰符标记参数</span><br><span class="line">fun &lt;T&gt; asList(vararg ts: T): List&lt;T&gt; &#123;</span><br><span class="line">    val result = ArrayList&lt;T&gt;()</span><br><span class="line">    for (t in ts) // ts is an Array</span><br><span class="line">        result.add(t)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val a = arrayOf(1, 2, 3)</span><br><span class="line">//*a代表把a里所有元素</span><br><span class="line">val list = asList(-1, 0, *a, 4)</span><br><span class="line">//运行代码，得到结果为： [-1, 0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p>
<h3 id="11-单表达式函数"><a href="#11-单表达式函数" class="headerlink" title="11.单表达式函数"></a>11.单表达式函数</h3><p>kotlin中，如果函数体只有一条语句且有返回值，那么可以省略函数体大括号，变成单表达式函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//函数体只有一条语句并且有返回值</span><br><span class="line">fun getName() : String&#123;</span><br><span class="line">	return &quot;张三&quot;</span><br><span class="line">&#125;</span><br><span class="line">//这时可以省略大括号,变成单表达式函数</span><br><span class="line">fun getName() = &quot;张三&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-局部函数"><a href="#12-局部函数" class="headerlink" title="12.局部函数"></a>12.局部函数</h3><p>kotlin支持在函数中嵌套定义另一个函数,嵌套在里面的函数称为局部函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun test()&#123;</span><br><span class="line">	Log.e(&quot;a&quot;, &quot;-1-&quot;)</span><br><span class="line">	</span><br><span class="line">	fun testInside()&#123;</span><br><span class="line">		Log.e(&quot;a&quot;, &quot;-2-&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	testInside()</span><br><span class="line">&#125;</span><br><span class="line">//调用test方法</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/05/28/kotlin/kotlin-3-genericity/">三、kotlin--&gt;对象和泛型</a><a class="next" href="/2018/05/24/kotlin/kotlin-1-basis/">一、kotlin基本语法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React-Native/">React Native</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/gitlab/">gitlab</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kotlin/">kotlin</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webview/">webview</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/weixin-mini-app/">weixin_mini_app</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/31/react-native-debug/">十三、react native如何在chrome中断点调试</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/react-native/11.Text记录/">十一、Text记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/react-native/12.Modal点击屏幕空白消失/">十二、自定义对话框Modal记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/react-native/10.TouchableOpacity的onPress方法失效/">九、TouchableOpacity的onPress方法失效</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/gitlab-fork-merge-request/">gitlab-fork-merge request</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/react-native/9.export笔记/">九、react-native的export笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/react-native/8.react-native的style记录/">八、react-native的style记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/21/react-native/7.添加间隔线/">七、添加间隔线</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/react-native/6.react-navigation记录/">六、react-navigation记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/13/react-native/4.onPress调用函数两种写法/">四、RN中onPress调用函数的两种写法踩坑</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">凡星的个人博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>